<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.js" integrity="sha256-ZdnRjhC/+YiBbXTHIuJdpf7u6Jh5D2wD5y0SNRWDREQ=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reconnecting-websocket/1.0.0/reconnecting-websocket.min.js" integrity="sha256-A4JwlcDvqO4JXpvEtvWY1RH8JAEMu5W21wP8GUXLUNs=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.css" integrity="sha256-f83N12sqX/GO43Y7vXNt9MjrHkPc4yi9Uq9cLy1wGIU=" crossorigin="anonymous" />
    <style type="text/css">
        body {
          background: #EEE;
        }

        #container {
          align-items: center;
          background-color: #ddd;
          display: flex;
          height: 400px;
          justify-content: center;
          overflow: hidden;
          position: relative;
          width: auto;
        }

        #viewer {
          flex: 0 0 1000px;
          transform: scale(4, 4);
          transform-origin: center;
        }

        #camera {
          transform: translate(0, 0);
        }

        canvas {
          -ms-interpolation-mode: bicubic;
          image-rendering: -moz-crisp-edges;
          image-rendering: -webkit-optimize-contrast;
          image-rendering: crisp-edges;
          image-rendering: pixelated;
          background-color: white;
          cursor: pointer;
          /*pointer-events: none;*/
          transform: translate(-1.5px,-1.5px);
          display: block;
          margin: 0 auto;
        }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="viewer">
        <div id="camera">
          <canvas id="canvas" width="50" height="50"></canvas>
        </div>
      </div>
    </div>
    <input id="colour" type="text" />
    <script type="application/javascript">
      const width = 50, height = 50;

      let palateEl = document.getElementById('colour');
      let containerEl = document.getElementById('container');
      let cameraEl = document.getElementById('camera');
      let el = document.getElementById('canvas');
      let ctx = el.getContext('2d');
      ctx.mozImageSmoothingEnabled = false;
      ctx.webkitImageSmoothingEnabled = false;
      ctx.msImageSmoothingEnabled = false;
      ctx.imageSmoothingEnabled = false;

      let buffer = new ArrayBuffer(width * height * 4);
      let array = new Uint8ClampedArray(buffer);

      function updateDisplay() {
        let e = new ImageData(array, width, height);
        ctx.putImageData(e, 0, 0);
      }

       function loadBitmap() {
        fetch('http://localhost:8080/api/place/board-bitmap')
          .then((res) => res.arrayBuffer())
          .then((data) => {
            buffer = data;
            array = new Uint8ClampedArray(buffer);

            updateDisplay();
          });
      }

      let zoom = 4, panX = 0, panY = 0;

      function getCoordinatesFromEvent(e) {
        let r = {
          x: parseInt(e.clientX, 10) + window.scrollX,
          y: parseInt(e.clientY, 10) + window.scrollY
        };

        let s = e.currentTarget ? e.currentTarget.offsetLeft : 0,
            o = e.currentTarget ? e.currentTarget.offsetTop : 0;

        let c = containerEl.getBoundingClientRect();
        return {
          x: Math.round((r.x - s) / zoom + width / 2 - c.width / (2 * zoom) - panX),
          y: Math.round((r.y - o) / zoom + height / 2 - c.height / (2 * zoom) - panY)
        };
      }

      function toHexString(byteArray) {
        return byteArray.map(function(byte) {
          return ('0' + (byte & 0xFF).toString(16)).slice(-2);
        }).join('')
      }

      function parseHexString(str) {
        var result = [];
        while (str.length >= 2) {
          result.push(parseInt(str.substring(0, 2), 16));

          str = str.substring(2, str.length);
        }

        return result;
      }

      let pickingColour = false;
      let PALATE = [0x00, 0x00, 0x00, 0xff];
      $(palateEl).spectrum({
        show: () => {
          pickingColour = true;
        },
        hide: () => {
          pickingColour = false;
        },
        change: (colour) => {
          let {r, g, b, a} = colour.toRgb();

          PALATE[0] = r;
          PALATE[1] = g;
          PALATE[2] = b;
          PALATE[3] = Math.round(a * 0xff);

          console.log({r,g,b,a}, PALATE);
        }
      });

      cameraEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });

      function getOffset(x, y) {
        return (width*(y-1) + (x-1)) * 4;
      }

      function drawPixel(x, y, colour) {
        const offset = getOffset(x, y)
        array.set(colour, offset);
        updateDisplay();
      }

      // Create WebSocket connection.
      const socket = new ReconnectingWebSocket('ws://localhost:8080/api/place/live');

      // Connection opened
      socket.addEventListener('open', (event) => {
        // TODO: enable editing now that we've opened the websocket connection.
      });

      cameraEl.addEventListener('mouseup', (e) => {

        // If we're picking a colour, don't draw anything.
        if (pickingColour) {
          return;
        }

        // If this was the contextmenu, exit.
        if (e.which === 3) {
          return;
        }

        const {x, y} = getCoordinatesFromEvent(e);

        // Compute th eoffset in the array.
        const offset = getOffset(x, y);

        // Get the current colour.
        const colour = array.slice(offset, offset + 4);

        // If the current colour is already there, don't bother writing it...
        if (colour.length === PALATE.length && colour.every((v, i) => v === PALATE[i])) {
          return;
        }

        // This is a new colour! Draw it locally and push it up the websocket.
        drawPixel(x, y, PALATE);
        socket.send(JSON.stringify({
          X: `${x}`,
          Y: `${y}`,
          Colour: toHexString(PALATE)
        }));
      }, false);

      loadBitmap();

      // Listen for messages
      socket.addEventListener('message', (event) => {
        const {X, Y, Colour} = JSON.parse(event.data);

        drawPixel(X, Y, parseHexString(Colour));
      });
    </script>
  </body>
</html>